<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Wetter">
    <meta name="theme-color" content="#0ea5e9">
    <link rel="apple-touch-icon" href="AppleIcon.png">
    <title>Better</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }
        body {
            transition: background 0.5s ease;
            -webkit-tap-highlight-color: transparent;
        }


        body.theme-light {
            background: linear-gradient(180deg, #38bdf8 0%, #2563eb 100%);
        }
        body.theme-dark {
            background: linear-gradient(180deg, #0f172a 0%, #1e1b4b 100%);
        }


        /* iOS Overscroll-Fix: Fester Hintergrund-Layer, der beim Rubber-Banding sichtbar bleibt */
        .background-layer {
            position: fixed;
            inset: 0;
            z-index: -1;
            transition: background 0.5s ease;
        }
        .glass {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }
        /* Temperature Graph */
        .graph-line {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawLine 1.5s ease forwards;
        }
        .graph-dot {
            opacity: 0;
            animation: fadeInDot 0.3s ease forwards;
        }
        @keyframes drawLine {
            to { stroke-dashoffset: 0; }
        }
        @keyframes fadeInDot {
            to { opacity: 1; }
        }
        .graph-tooltip {
            pointer-events: none;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        #hourly-scroll::-webkit-scrollbar {
            display: none;
        }

        /* Sheet-Overlay Fade */
        #day-sheet-overlay {
            opacity: 0;
            pointer-events: none;
            transition: opacity 350ms cubic-bezier(0.32, 0.72, 0, 1);
        }
        #day-sheet-overlay.sheet-active {
            opacity: 1;
            pointer-events: auto;
        }
        /* Sheet Panel Slide-Animation */
        #day-sheet {
            transform: translateY(100%);
            transition: transform 350ms cubic-bezier(0.32, 0.72, 0, 1);
            will-change: transform;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            overflow-y: auto;
        }
        #day-sheet.sheet-open {
            transform: translateY(0);
        }
        /* Drag: Transition deaktivieren w√§hrend Ziehen */
        #day-sheet.sheet-dragging {
            transition: none !important;
        }
        /* Graph-Interaktions-Tooltip (fixed, schwebt √ºber allem) */
        .day-graph-tooltip {
            pointer-events: none;
            z-index: 60;
        }
        #app {
            position: absolute;
            inset: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-y: contain;
            padding-bottom: env(safe-area-inset-bottom);
        }

    </style>
</head>
<body class="theme-light min-h-screen text-white font-sans">

    <!-- iOS Overscroll-Fix: Fester Hintergrund-Layer, verhindert wei√üen Rand beim Rubber-Banding -->
    <div id="background-layer" class="background-layer"></div>

    <!-- ========================================
         HAUPTBEREICH
         Komplettes Layout statisch im HTML.
         Keine Layout-Erzeugung im Script.
         Alle dynamischen Bereiche mit eindeutigen IDs.
         ======================================== -->
    <main id="app" class="h-full p-5 pt-14 pb-10 max-w-md mx-auto select-none">

        <!-- Header: Stadtname + Steuerung -->
        <header id="header" class="text-center mb-8 relative">
            <button id="refresh-btn"
                    class="absolute top-0 left-0 text-white/70 text-2xl w-10 h-10 flex items-center justify-center rounded-full active:bg-white/10"
                    aria-label="Aktualisieren">
                ‚Üª
            </button>
            <button id="city-toggle-btn"
                    class="inline-flex items-center gap-1"
                    aria-label="Stadt wechseln">
                <span id="city-name" class="text-lg font-medium tracking-wide">‚Äî</span>
                <svg class="w-4 h-4 opacity-60" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
        </header>

        <!-- Aktuelles Wetter -->
        <section id="current-weather" class="text-center mb-10">
            <div id="weather-icon" class="text-8xl mb-2 leading-none">‚Äî</div>
            <div id="current-temp" class="text-8xl font-extralight tracking-tighter mb-1">‚Äî</div>
            <div id="weather-desc" class="text-lg opacity-80 mb-1">‚Äî</div>
            <div id="apparent-temp" class="text-sm opacity-60">‚Äî</div>
        </section>

        <!-- Detail-Karten: Wind, Feuchtigkeit, Regen -->
        <section id="details" class="grid grid-cols-3 gap-3 mb-5">
            <div class="glass rounded-2xl p-3 text-center">
                <div class="text-xs opacity-60 uppercase tracking-wider mb-1">Wind</div>
                <div id="wind-speed" class="text-xl font-semibold">‚Äî</div>
            </div>
            <div class="glass rounded-2xl p-3 text-center">
                <div class="text-xs opacity-60 uppercase tracking-wider mb-1">Feuchte</div>
                <div id="humidity" class="text-xl font-semibold">‚Äî</div>
            </div>
            <div class="glass rounded-2xl p-3 text-center">
                <div class="text-xs opacity-60 uppercase tracking-wider mb-1">Regen</div>
                <div id="rain-probability" class="text-xl font-semibold">‚Äî</div>
            </div>
        </section>

        <section id="hourly-section" class="mb-6 glass rounded-2xl p-4 text-center">
            <div id="hourly-scroll" class="flex overflow-x-auto no-scrollbar"></div>
        </section>

        <!-- 10-Tage-Vorhersage -->
        <section id="forecast" class="glass rounded-2xl p-4">
            <h2 class="text-xs opacity-60 uppercase tracking-wider mb-3">10-Tage-Vorhersage</h2>
            <div id="forecast-list" class="divide-y divide-white/10"></div>
        </section>

        <!-- Sonnenzeiten -->
        <section id="sun-times" class="glass rounded-2xl p-4 mb-5 mt-5 flex justify-around">
            <div class="text-center">
                <div class="text-xs opacity-60 uppercase tracking-wider mb-1">‚òÄ Aufgang</div>
                <div id="sunrise" class="text-xl font-semibold">‚Äî</div>
            </div>
            <div class="w-px bg-white/20"></div>
            <div class="text-center">
                <div class="text-xs opacity-60 uppercase tracking-wider mb-1">‚òΩ Untergang</div>
                <div id="sunset" class="text-xl font-semibold">‚Äî</div>
            </div>
        </section>

        <!-- Temperatur-Graph -->
        <section id="temp-graph-section" class="glass rounded-2xl p-4 mt-5 relative">
            <h2 class="text-xs opacity-60 uppercase tracking-wider mb-3">Temperaturverlauf</h2>
            <svg id="temp-graph" viewBox="0 0 320 160" class="w-full" preserveAspectRatio="xMidYMid meet"></svg>
            <div id="graph-tooltip" class="graph-tooltip absolute hidden bg-slate-900/90 backdrop-blur text-white text-xs rounded-lg px-3 py-2 shadow-lg z-10"></div>
        </section>

    </main>

    <!-- Stadteingabe-Overlay -->
    <div id="city-overlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-start justify-center pt-28 px-5">
        <div class="bg-slate-800/95 backdrop-blur-lg rounded-2xl p-5 w-full max-w-sm shadow-2xl">
            <h3 class="text-white text-lg font-semibold mb-4">Stadt suchen</h3>
            <input id="city-input"
                   type="text"
                   class="w-full bg-slate-700/80 text-white rounded-xl px-4 py-3 mb-4 outline-none focus:ring-2 focus:ring-blue-400 placeholder-white/40"
                   placeholder="Stadtname eingeben‚Ä¶"
                   autocomplete="off" />
            <div class="flex gap-3">
                <button id="city-cancel-btn"
                        class="flex-1 bg-slate-700 text-white/80 rounded-xl py-3 font-medium active:bg-slate-600">
                    Abbrechen
                </button>
                <button id="city-submit-btn"
                        class="flex-1 bg-blue-500 text-white rounded-xl py-3 font-medium active:bg-blue-600">
                    Suchen
                </button>
            </div>
        </div>
    </div>

    <!-- Lade-Overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-black/20 backdrop-blur-sm z-40 flex items-center justify-center">
        <div class="flex flex-col items-center gap-3">
            <div class="w-10 h-10 border-white/30 border-t-white rounded-full spinner" style="border-width: 3px; border-style: solid"></div>
            <span class="text-white/80 text-sm">Wetterdaten laden‚Ä¶</span>
        </div>
    </div>

    <!-- Fehlermeldung -->
    <div id="error-display" class="hidden fixed bottom-6 left-4 right-4 bg-red-500/90 backdrop-blur text-white rounded-2xl p-4 text-center text-sm z-50 shadow-lg max-w-md mx-auto"></div>

    <!-- Tages-Detail Bottom Sheet -->
    <div id="day-sheet-overlay" class="fixed inset-0 bg-black/40 backdrop-blur-sm z-50">
        <div id="day-sheet" class="absolute bottom-0 left-0 right-0 bg-slate-800/95 backdrop-blur-lg rounded-t-3xl p-5 pt-3 max-w-md mx-auto shadow-2xl text-white" style="max-height:85vh;overflow-y:auto">
            <!-- Drag-Handle -->
            <div id="day-sheet-handle" class="flex justify-center mb-3 pt-1 cursor-grab active:cursor-grabbing" style="touch-action:none">
                <div class="w-10 h-1 rounded-full bg-white/30"></div>
            </div>
            <!-- Titel -->
            <h3 id="day-sheet-title" class="text-lg font-semibold text-center mb-4"></h3>
            <!-- Temperatur-Graph -->
            <div class="mb-2 relative">
                <h4 class="text-xs opacity-60 uppercase tracking-wider mb-2">Temperatur</h4>
                <svg id="day-temp-graph" viewBox="0 0 320 160" class="w-full" preserveAspectRatio="xMidYMid meet" style="touch-action:none"></svg>
            </div>
            <!-- Regen-Graph -->
            <div class="relative">
                <h4 class="text-xs opacity-60 uppercase tracking-wider mb-2">Niederschlag</h4>
                <svg id="day-rain-graph" viewBox="0 0 320 160" class="w-full" preserveAspectRatio="xMidYMid meet" style="touch-action:none"></svg>
            </div>
        </div>
    </div>
    <!-- Graph-Interaktions-Tooltip (fixed, schwebt √ºber Sheet) -->
    <div id="day-graph-tooltip" class="day-graph-tooltip fixed hidden bg-black/80 text-white text-xs rounded-xl px-3 py-2 shadow-lg"></div>


<script>
'use strict';

// ========================================
// HELPER-FUNKTIONEN
// Reine Berechnungen. Kein State. Kein DOM.
// ========================================

// ----------------------------------------
// Funktion: calculateIsDarkMode
// Verantwortlichkeit: Pr√ºft ob aktuelle Uhrzeit nach Sonnenuntergang oder vor Sonnenaufgang liegt.
// Ver√§ndert: Nichts (pure Funktion)
// Ver√§ndert NICHT: state, DOM
// Architektur-Hinweis: Ergebnis wird vom Aufrufer in state.isDarkMode geschrieben.
// ----------------------------------------
function calculateIsDarkMode(sunriseStr, sunsetStr) {
    if (!sunriseStr || !sunsetStr) return false;
    const now = new Date();
    const sunrise = new Date(sunriseStr);
    const sunset = new Date(sunsetStr);
    return now < sunrise || now >= sunset;
}

// ----------------------------------------
// Funktion: mapWeatherCode
// Verantwortlichkeit: √úbersetzt WMO Weather Code in Icon (Emoji) und deutsche Beschreibung.
// Ver√§ndert: Nichts (pure Funktion)
// Ver√§ndert NICHT: state, DOM
// Architektur-Hinweis: Mapping nach WMO-Standard (Code-Tabelle 4677).
// ----------------------------------------
function mapWeatherCode(code, isNight) {
    const map = {
        0:  { icon: isNight ? 'üåô' : '‚òÄÔ∏è',  desc: 'Klar' },
        1:  { icon: isNight ? 'üåô' : 'üå§Ô∏è', desc: '√úberwiegend klar' },
        2:  { icon: '‚õÖ',  desc: 'Teilweise bew√∂lkt' },
        3:  { icon: '‚òÅÔ∏è',  desc: 'Bew√∂lkt' },
        45: { icon: 'üå´Ô∏è', desc: 'Nebel' },
        48: { icon: 'üå´Ô∏è', desc: 'Reifnebel' },
        51: { icon: 'üå¶Ô∏è', desc: 'Leichter Nieselregen' },
        53: { icon: 'üå¶Ô∏è', desc: 'Nieselregen' },
        55: { icon: 'üåßÔ∏è', desc: 'Starker Nieselregen' },
        56: { icon: 'üåßÔ∏è', desc: 'Gefrierender Nieselregen' },
        57: { icon: 'üåßÔ∏è', desc: 'Starker gefr. Nieselregen' },
        61: { icon: 'üåßÔ∏è', desc: 'Leichter Regen' },
        63: { icon: 'üåßÔ∏è', desc: 'Regen' },
        65: { icon: 'üåßÔ∏è', desc: 'Starker Regen' },
        66: { icon: 'üåßÔ∏è', desc: 'Gefrierender Regen' },
        67: { icon: 'üåßÔ∏è', desc: 'Starker gefr. Regen' },
        71: { icon: 'üå®Ô∏è', desc: 'Leichter Schneefall' },
        73: { icon: 'üå®Ô∏è', desc: 'Schneefall' },
        75: { icon: '‚ùÑÔ∏è',  desc: 'Starker Schneefall' },
        77: { icon: '‚ùÑÔ∏è',  desc: 'Schneek√∂rner' },
        80: { icon: 'üå¶Ô∏è', desc: 'Leichte Regenschauer' },
        81: { icon: 'üåßÔ∏è', desc: 'Regenschauer' },
        82: { icon: 'üåßÔ∏è', desc: 'Heftige Regenschauer' },
        85: { icon: 'üå®Ô∏è', desc: 'Leichte Schneeschauer' },
        86: { icon: 'üå®Ô∏è', desc: 'Starke Schneeschauer' },
        95: { icon: '‚õàÔ∏è', desc: 'Gewitter' },
        96: { icon: '‚õàÔ∏è', desc: 'Gewitter mit Hagel' },
        99: { icon: '‚õàÔ∏è', desc: 'Starkes Gewitter mit Hagel' }
    };
    return map[code] || { icon: '‚ùì', desc: 'Unbekannt' };
}

// Gibt deutschen Wochentag oder "Heute"/"Morgen" zur√ºck.
function formatDay(dateStr) {
    const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
    const date = new Date(dateStr + 'T00:00:00');
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const compare = new Date(dateStr + 'T00:00:00');
    compare.setHours(0, 0, 0, 0);
    if (compare.getTime() === today.getTime()) return 'Heute';
    if (compare.getTime() === tomorrow.getTime()) return 'Morgen';
    return days[date.getDay()];
}

// Extrahiert Uhrzeit (HH:MM) aus ISO-String.
function formatTime(isoStr) {
    if (!isoStr) return '‚Äî';
    const d = new Date(isoStr);
    return d.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
}


// ========================================
// STATE
// Zentrales, direkt mutierbares Zustandsobjekt.
// Jede Mutation MUSS unmittelbar updateUI() ausl√∂sen.
// ========================================

const state = {
    latitude: null,
    longitude: null,
    cityName: '',
    currentTemp: null,
    currentWeatherCode: null,
    humidity: null,
    windSpeed: null,
    apparentTemp: null,
    sunrise: '',
    sunset: '',
    rainProbabilityToday: null,
    forecast: [],
    isDarkMode: false,
    isLoading: false,
    error: null,
    showCityInput: false,
    cityInputValue: '',
    hourly: [],
    rawHourly: null,
    selectedDayIndex: null,
    isSheetOpen: false,
    sheetDragOffset: 0
};


// ========================================
// DOM-CACHE
// Einmaliges Caching aller ben√∂tigten Elemente.
// Kein verstreutes getElementById im restlichen Code.
// ========================================

let $ = {};

// ----------------------------------------
// Funktion: cacheDom
// Verantwortlichkeit: Cached alle DOM-Referenzen in das $-Objekt.
// Ver√§ndert: $ (DOM-Cache-Objekt)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Wird genau einmal zu Beginn des Lifecycle aufgerufen.
// ----------------------------------------
function cacheDom() {
    $ = {
        body:            document.body,
        cityName:        document.getElementById('city-name'),
        cityToggleBtn:   document.getElementById('city-toggle-btn'),
        refreshBtn:      document.getElementById('refresh-btn'),
        weatherIcon:     document.getElementById('weather-icon'),
        currentTemp:     document.getElementById('current-temp'),
        weatherDesc:     document.getElementById('weather-desc'),
        apparentTemp:    document.getElementById('apparent-temp'),
        windSpeed:       document.getElementById('wind-speed'),
        humidity:        document.getElementById('humidity'),
        rainProbability: document.getElementById('rain-probability'),
        sunrise:         document.getElementById('sunrise'),
        sunset:          document.getElementById('sunset'),
        forecastList:    document.getElementById('forecast-list'),
        cityOverlay:     document.getElementById('city-overlay'),
        cityInput:       document.getElementById('city-input'),
        citySubmitBtn:   document.getElementById('city-submit-btn'),
        cityCancelBtn:   document.getElementById('city-cancel-btn'),
        loadingOverlay:  document.getElementById('loading-overlay'),
        errorDisplay:    document.getElementById('error-display'),
        tempGraph:       document.getElementById('temp-graph'),
        tempGraphSection:document.getElementById('temp-graph-section'),
        graphTooltip:    document.getElementById('graph-tooltip'),
        hourlyScroll:    document.getElementById('hourly-scroll'),
        daySheetOverlay: document.getElementById('day-sheet-overlay'),
        daySheet:        document.getElementById('day-sheet'),
        daySheetTitle:   document.getElementById('day-sheet-title'),
        dayTempGraph:    document.getElementById('day-temp-graph'),
        dayRainGraph:    document.getElementById('day-rain-graph'),
        daySheetHandle:  document.getElementById('day-sheet-handle'),
        dayGraphTooltip: document.getElementById('day-graph-tooltip'),
        app: document.getElementById('app')
    };
}


// ========================================
// STATE-MUTATIONS-FUNKTIONEN
// Ver√§ndern ausschlie√ülich state.
// Rufen danach immer updateUI() auf.
// Kein DOM-Zugriff.
// ========================================

// ----------------------------------------
// Funktion: setLocation
// Verantwortlichkeit: Schreibt Standortdaten in state.
// Ver√§ndert: state.latitude, state.longitude, state.cityName
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Wird nach GPS-Erkennung oder Stadtsuche aufgerufen.
// ----------------------------------------
function setLocation(lat, lon, name) {
    state.latitude = lat;
    state.longitude = lon;
    state.cityName = name;
    updateUI();
}

// ----------------------------------------
// Funktion: setWeatherData
// Verantwortlichkeit: Parst die API-Antwort und schreibt alle Wetterdaten in state.
// Ver√§ndert: state (alle Wetterfelder, forecast-Array, isDarkMode)
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Berechnet isDarkMode via Helper-Funktion.
// ----------------------------------------
function setWeatherData(data) {
    const current = data.current;
    const daily = data.daily;

    state.currentTemp = Math.round(current.temperature_2m);
    state.currentWeatherCode = current.weather_code;
    state.humidity = current.relative_humidity_2m;
    state.windSpeed = Math.round(current.wind_speed_10m);
    state.apparentTemp = Math.round(current.apparent_temperature);
    state.sunrise = daily.sunrise[0];
    state.sunset = daily.sunset[0];
    state.rainProbabilityToday = daily.precipitation_probability_max[0];
    state.isDarkMode = calculateIsDarkMode(state.sunrise, state.sunset);

    state.forecast = [];
    for (let i = 0; i < daily.time.length; i++) {
        state.forecast.push({
            date: daily.time[i],
            tempMax: Math.round(daily.temperature_2m_max[i]),
            tempMin: Math.round(daily.temperature_2m_min[i]),
            weatherCode: daily.weather_code[i],
            rainProbability: daily.precipitation_probability_max[i],
            windSpeed: Math.round(daily.wind_speed_10m_max[i])
        });
    }

    state.isLoading = false;
    state.error = null;
    state.hourly = buildHourlyForecast(data.hourly);
    state.rawHourly = data.hourly;
    updateUI();
}

// ----------------------------------------
// Funktion: setError
// Verantwortlichkeit: Setzt eine Fehlermeldung in state und plant deren Ausblendung.
// Ver√§ndert: state.error, state.isLoading
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Fehler werden ausschlie√ülich √ºber state.error transportiert.
// ----------------------------------------
function setError(msg) {
    state.error = msg;
    state.isLoading = false;
    updateUI();
    setTimeout(clearError, 5000);
}

// ----------------------------------------
// Funktion: clearError
// Verantwortlichkeit: Entfernt die Fehlermeldung aus state.
// Ver√§ndert: state.error
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function clearError() {
    state.error = null;
    updateUI();
}

// ----------------------------------------
// Funktion: setLoading
// Verantwortlichkeit: Setzt den Ladezustand.
// Ver√§ndert: state.isLoading
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function setLoading(val) {
    state.isLoading = val;
    updateUI();
}


// ========================================
// UPDATE-FUNKTIONEN
// Lesen ausschlie√ülich state, schreiben ausschlie√ülich DOM.
// Keine State-Mutation. Keine Berechnungen.
// Jede Funktion hat exakt eine Verantwortlichkeit.
// ========================================

// ----------------------------------------
// Funktion: updateUI
// Verantwortlichkeit: Zentrale Update-Funktion ‚Äì ruft ALLE Teil-Updates auf.
// Ver√§ndert: DOM (via Teil-Update-Funktionen)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Einziger Einstiegspunkt f√ºr alle DOM-Aktualisierungen.
// ----------------------------------------
function updateUI() {
    updateTheme();
    updateHeader();
    updateCurrentWeather();
    updateDetails();
    updateSunTimes();
    updateHourlyForecast();
    updateForecastList();
    updateTemperatureGraph();
    updateLoadingState();
    updateErrorDisplay();
    updateCityOverlay();
    updateDayDetailSheet();
}

function buildHourlyForecast(hourlyData) {
    const now = new Date();
    const result = [];

    let startIndex = -1;

    for (let i = 0; i < hourlyData.time.length; i++) {
        const t = new Date(hourlyData.time[i]);
        if (t > now) {
            startIndex = i;
            break;
        }
    }

    if (startIndex === -1) return [];

    const slice = hourlyData.time.slice(startIndex, startIndex + 24);

    for (let i = 0; i < slice.length; i++) {
        result.push({
            timeISO: hourlyData.time[startIndex + i],
            temperature: Math.round(hourlyData.temperature_2m[startIndex + i]),
            weatherCode: hourlyData.weather_code[startIndex + i],
            isNow: i === 0
        });
    }

    return result;
}

function updateHourlyForecast() {
    if (!state.hourly || state.hourly.length === 0) {
        $.hourlyScroll.replaceChildren();
        return;
    }

    const items = [];

    for (let i = 0; i < state.hourly.length; i++) {
        const hour = state.hourly[i];

        const container = document.createElement('div');
        container.classList.add(
            'flex',
            'flex-col',
            'items-center',
            'min-w-[56px]',
            'text-center'
        );

        // Zeitlabel
        const timeLabel = document.createElement('span');
        timeLabel.classList.add('text-xs', 'opacity-60', 'mb-1');

        if (hour.isNow) {
            timeLabel.textContent = 'Jetzt';
        } else {
            const d = new Date(hour.timeISO);
            timeLabel.textContent = d.toLocaleTimeString('de-DE', {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Icon
        const weather = mapWeatherCode(hour.weatherCode, false);

        const icon = document.createElement('span');
        icon.classList.add('text-2xl', 'mb-1');
        icon.textContent = weather.icon;

        // Temperatur
        const temp = document.createElement('span');
        temp.classList.add('text-sm', 'font-medium');
        temp.textContent = hour.temperature + '¬∞';

        container.appendChild(timeLabel);
        container.appendChild(icon);
        container.appendChild(temp);

        items.push(container);
    }

    $.hourlyScroll.replaceChildren(...items);
}



// ----------------------------------------
// Funktion: updateTheme
// Verantwortlichkeit: Schaltet Dark/Light-Klassen auf dem body-Element und aktualisiert den Background-Layer.
// Ver√§ndert: DOM (body classList, background-layer style)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Der Background-Layer (position:fixed) verhindert wei√üen Rand beim iOS-Overscroll.
// ----------------------------------------
function updateTheme() {
    const bg = document.getElementById('background-layer');

    if (state.isDarkMode) {
        $.body.classList.add('theme-dark');
        $.body.classList.remove('theme-light');
        bg.style.background = 'linear-gradient(180deg, #0f172a 0%, #1e1b4b 100%)'; }

    else {
        $.body.classList.add('theme-light');
        $.body.classList.remove('theme-dark');
        bg.style.background = 'linear-gradient(180deg, #38bdf8 0%, #2563eb 100%)'; } }

// ----------------------------------------
// Funktion: updateHeader
// Verantwortlichkeit: Zeigt den aktuellen Stadtnamen an.
// Ver√§ndert: DOM (city-name textContent)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateHeader() {
    $.cityName.textContent = state.cityName || 'Standort wird ermittelt‚Ä¶';
}

// ----------------------------------------
// Funktion: updateCurrentWeather
// Verantwortlichkeit: Zeigt aktuelle Temperatur, Icon und Beschreibung an.
// Ver√§ndert: DOM (weather-icon, current-temp, weather-desc, apparent-temp)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateCurrentWeather() {
    if (state.currentTemp === null) return;
    const weather = mapWeatherCode(state.currentWeatherCode, state.isDarkMode);
    $.weatherIcon.textContent = weather.icon;
    $.currentTemp.textContent = state.currentTemp + '¬∞';
    $.weatherDesc.textContent = weather.desc;
    $.apparentTemp.textContent = 'Gef√ºhlt ' + state.apparentTemp + '¬∞';
}

// ----------------------------------------
// Funktion: updateDetails
// Verantwortlichkeit: Zeigt Wind, Luftfeuchtigkeit und Regenwahrscheinlichkeit.
// Ver√§ndert: DOM (wind-speed, humidity, rain-probability)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateDetails() {
    if (state.windSpeed === null) return;
    $.windSpeed.textContent = state.windSpeed + ' km/h';
    $.humidity.textContent = state.humidity + '%';
    $.rainProbability.textContent = state.rainProbabilityToday !== null
        ? state.rainProbabilityToday + '%'
        : '‚Äî';
}

// ----------------------------------------
// Funktion: updateSunTimes
// Verantwortlichkeit: Zeigt Sonnenaufgangs- und Sonnenuntergangszeit an.
// Ver√§ndert: DOM (sunrise, sunset)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateSunTimes() {
    $.sunrise.textContent = formatTime(state.sunrise);
    $.sunset.textContent = formatTime(state.sunset);
}

// ----------------------------------------
// Funktion: updateForecastList
// Verantwortlichkeit: Erzeugt die 10-Tage-Vorhersage-Zeilen per createElement + replaceChildren.
// Ver√§ndert: DOM (forecast-list Kindelemente)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Kein innerHTML. Kein Template-String-Rendering. Ausschlie√ülich createElement.
// ----------------------------------------
function updateForecastList() {
    if (state.forecast.length === 0) return;

    const items = [];

    for (let i = 0; i < state.forecast.length; i++) {
        const day = state.forecast[i];
        const weather = mapWeatherCode(day.weatherCode, false);

        const row = document.createElement('div');
        row.classList.add('flex', 'items-center', 'justify-between', 'py-3', 'cursor-pointer', 'active:bg-white/5', 'rounded-lg', '-mx-1', 'px-1');
        row.setAttribute('data-day-index', i.toString());
        row.addEventListener('click', handleForecastDayClick);

        const dayLabel = document.createElement('span');
        dayLabel.classList.add('w-16', 'text-sm', 'font-medium');
        dayLabel.textContent = formatDay(day.date);

        const icon = document.createElement('span');
        icon.classList.add('text-2xl', 'w-10', 'text-center');
        icon.textContent = weather.icon;

        const rain = document.createElement('span');
        rain.classList.add('text-xs', 'text-blue-200', 'w-12', 'text-center');
        rain.textContent = day.rainProbability + '%';

        const temps = document.createElement('span');
        temps.classList.add('text-sm', 'text-right', 'w-24');

        const tempMin = document.createElement('span');
        tempMin.classList.add('opacity-50');
        tempMin.textContent = day.tempMin + '¬∞';

        const spacer = document.createElement('span');
        spacer.textContent = '  ';

        const tempMax = document.createElement('span');
        tempMax.classList.add('font-semibold');
        tempMax.textContent = day.tempMax + '¬∞';

        temps.appendChild(tempMin);
        temps.appendChild(spacer);
        temps.appendChild(tempMax);

        row.appendChild(dayLabel);
        row.appendChild(icon);
        row.appendChild(rain);
        row.appendChild(temps);

        items.push(row);
    }

    $.forecastList.replaceChildren.apply($.forecastList, items);
}

// ----------------------------------------
// Funktion: updateTemperatureGraph
// Verantwortlichkeit: Zeichnet den SVG-Temperatur-Graphen mit Linien, Punkten und Hover-Bereichen.
// Ver√§ndert: DOM (temp-graph SVG Kindelemente)
// Ver√§ndert NICHT: state
// ----------------------------------------
let _prevForecastKey = '';

function updateTemperatureGraph() {
    if (state.forecast.length === 0) return;

    // Nur neu zeichnen wenn sich die Daten ge√§ndert haben
    const key = state.forecast.map(function(d) { return d.tempMax + ',' + d.tempMin; }).join('|');
    if (key === _prevForecastKey) return;
    _prevForecastKey = key;

    const svg = $.tempGraph;
    const W = 320, H = 160;
    const padL = 8, padR = 8, padT = 25, padB = 30;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    const days = state.forecast;
    const n = days.length;

    // Temperatur-Range bestimmen
    const allTemps = [];
    for (let i = 0; i < n; i++) {
        allTemps.push(days[i].tempMax);
        allTemps.push(days[i].tempMin);
    }
    const tMin = Math.min.apply(null, allTemps) - 2;
    const tMax = Math.max.apply(null, allTemps) + 2;
    const tRange = tMax - tMin || 1;

    function x(idx) { return padL + (plotW / (n - 1)) * idx; }
    function y(temp) { return padT + plotH - ((temp - tMin) / tRange) * plotH; }

    const NS = 'http://www.w3.org/2000/svg';

    function el(tag, attrs) {
        const node = document.createElementNS(NS, tag);
        for (const k in attrs) {
            if (attrs.hasOwnProperty(k)) node.setAttribute(k, attrs[k]);
        }
        return node;
    }

    const frag = document.createDocumentFragment();

    // Horizontale Hilfslinien
    const lineCount = 4;
    for (let li = 0; li <= lineCount; li++) {
        const yy = padT + (plotH / lineCount) * li;
        const gridLine = el('line', {
            x1: padL, y1: yy, x2: W - padR, y2: yy,
            stroke: 'rgba(255,255,255,0.08)', 'stroke-width': '0.5'
        });
        frag.appendChild(gridLine);
    }

    // Pfad-Strings bauen
    let maxPath = '', minPath = '';
    for (let i = 0; i < n; i++) {
        const px = x(i).toFixed(1);
        const pyMax = y(days[i].tempMax).toFixed(1);
        const pyMin = y(days[i].tempMin).toFixed(1);
        maxPath += (i === 0 ? 'M' : 'L') + px + ',' + pyMax;
        minPath += (i === 0 ? 'M' : 'L') + px + ',' + pyMin;
    }

    // Gef√ºllte Fl√§che zwischen Max und Min
    let areaPath = maxPath;
    for (let i = n - 1; i >= 0; i--) {
        areaPath += 'L' + x(i).toFixed(1) + ',' + y(days[i].tempMin).toFixed(1);
    }
    areaPath += 'Z';

    const gradient = el('defs', {});
    const grad = el('linearGradient', { id: 'areaGrad', x1: '0', y1: '0', x2: '0', y2: '1' });
    const stop1 = el('stop', { offset: '0%', 'stop-color': 'rgba(255,255,255,0.15)' });
    const stop2 = el('stop', { offset: '100%', 'stop-color': 'rgba(255,255,255,0.02)' });
    grad.appendChild(stop1);
    grad.appendChild(stop2);
    gradient.appendChild(grad);
    frag.appendChild(gradient);

    const area = el('path', {
        d: areaPath,
        fill: 'url(#areaGrad)'
    });
    frag.appendChild(area);

    // Min-Linie
    const minLine = el('path', {
        d: minPath,
        fill: 'none',
        stroke: 'rgba(147,197,253,0.5)',
        'stroke-width': '1.5',
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round',
        class: 'graph-line'
    });
    frag.appendChild(minLine);

    // Max-Linie
    const maxLine = el('path', {
        d: maxPath,
        fill: 'none',
        stroke: 'rgba(255,255,255,0.9)',
        'stroke-width': '2',
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round',
        class: 'graph-line'
    });
    frag.appendChild(maxLine);

    // Punkte und Labels
    for (let i = 0; i < n; i++) {
        const cx = x(i);
        const delay = (i * 0.08 + 0.4) + 's';

        // Max-Punkt
        const dotMax = el('circle', {
            cx: cx.toFixed(1), cy: y(days[i].tempMax).toFixed(1), r: '3',
            fill: 'white', class: 'graph-dot', style: 'animation-delay:' + delay
        });
        frag.appendChild(dotMax);

        // Min-Punkt
        const dotMin = el('circle', {
            cx: cx.toFixed(1), cy: y(days[i].tempMin).toFixed(1), r: '2.5',
            fill: 'rgba(147,197,253,0.7)', class: 'graph-dot', style: 'animation-delay:' + delay
        });
        frag.appendChild(dotMin);

        // Tag-Label unten
        const label = el('text', {
            x: cx.toFixed(1), y: (H - 8).toString(),
            'text-anchor': 'middle', fill: 'rgba(255,255,255,0.5)',
            'font-size': '9', 'font-family': 'inherit'
        });
        label.textContent = formatDay(days[i].date);
        frag.appendChild(label);

        // Unsichtbarer Hover-Bereich
        const hitArea = el('rect', {
            x: (cx - plotW / n / 2).toFixed(1), y: padT.toString(),
            width: (plotW / n).toFixed(1), height: plotH.toString(),
            fill: 'transparent', 'data-index': i.toString(),
            style: 'cursor:pointer'
        });
        hitArea.addEventListener('mouseenter', handleGraphHover);
        hitArea.addEventListener('mousemove', handleGraphMove);
        hitArea.addEventListener('mouseleave', handleGraphLeave);
        hitArea.addEventListener('touchstart', handleGraphTouch, { passive: true });
        frag.appendChild(hitArea);
    }

    svg.replaceChildren(frag);
}

// ----------------------------------------
// Graph-Tooltip Handler
// ----------------------------------------
function handleGraphHover(e) {
    const idx = parseInt(e.target.getAttribute('data-index'));
    const day = state.forecast[idx];
    if (!day) return;
    const weather = mapWeatherCode(day.weatherCode, false);
    $.graphTooltip.innerHTML =
        '<div class="font-semibold mb-1">' + formatDay(day.date) + '</div>' +
        '<div>' + weather.icon + ' ' + day.tempMax + '¬∞ / ' + day.tempMin + '¬∞</div>' +
        '<div class="opacity-60 mt-0.5">Wind ' + day.windSpeed + ' km/h ¬∑ Regen ' + day.rainProbability + '%</div>';
    $.graphTooltip.classList.remove('hidden');
}

function handleGraphMove(e) {
    const section = $.tempGraphSection;
    const rect = section.getBoundingClientRect();
    const xPos = e.clientX - rect.left;
    const yPos = e.clientY - rect.top;
    const ttW = $.graphTooltip.offsetWidth;
    let left = xPos - ttW / 2;
    if (left < 8) left = 8;
    if (left + ttW > rect.width - 8) left = rect.width - ttW - 8;
    $.graphTooltip.style.left = left + 'px';
    $.graphTooltip.style.top = (yPos - $.graphTooltip.offsetHeight - 10) + 'px';
}

function handleGraphLeave() {
    $.graphTooltip.classList.add('hidden');
}

function handleGraphTouch(e) {
    const touch = e.touches[0];
    const idx = parseInt(e.target.getAttribute('data-index'));
    const day = state.forecast[idx];
    if (!day) return;
    const weather = mapWeatherCode(day.weatherCode, false);
    $.graphTooltip.innerHTML =
        '<div class="font-semibold mb-1">' + formatDay(day.date) + '</div>' +
        '<div>' + weather.icon + ' ' + day.tempMax + '¬∞ / ' + day.tempMin + '¬∞</div>' +
        '<div class="opacity-60 mt-0.5">Wind ' + day.windSpeed + ' km/h ¬∑ Regen ' + day.rainProbability + '%</div>';
    $.graphTooltip.classList.remove('hidden');

    const section = $.tempGraphSection;
    const rect = section.getBoundingClientRect();
    const xPos = touch.clientX - rect.left;
    const ttW = $.graphTooltip.offsetWidth;
    let left = xPos - ttW / 2;
    if (left < 8) left = 8;
    if (left + ttW > rect.width - 8) left = rect.width - ttW - 8;
    $.graphTooltip.style.left = left + 'px';
    $.graphTooltip.style.top = '8px';

    clearTimeout(handleGraphTouch._timer);
    handleGraphTouch._timer = setTimeout(handleGraphLeave, 2000);
}

// ----------------------------------------
// Funktion: updateLoadingState
// Verantwortlichkeit: Zeigt oder verbirgt das Lade-Overlay.
// Ver√§ndert: DOM (loading-overlay classList)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateLoadingState() {
    if (state.isLoading) {
        $.loadingOverlay.classList.remove('hidden');
    } else {
        $.loadingOverlay.classList.add('hidden');
    }
}

// ----------------------------------------
// Funktion: updateErrorDisplay
// Verantwortlichkeit: Zeigt oder verbirgt die Fehlermeldung.
// Ver√§ndert: DOM (error-display classList, textContent)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateErrorDisplay() {
    if (state.error) {
        $.errorDisplay.textContent = state.error;
        $.errorDisplay.classList.remove('hidden');
    } else {
        $.errorDisplay.classList.add('hidden');
    }
}

// ----------------------------------------
// Funktion: updateCityOverlay
// Verantwortlichkeit: Zeigt oder verbirgt das Stadteingabe-Overlay. Fokussiert Input beim √ñffnen.
// Ver√§ndert: DOM (city-overlay classList, city-input focus/value)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Pr√ºft classList, um Fokus nur beim erstmaligen √ñffnen zu setzen.
// ----------------------------------------
function updateCityOverlay() {
    if (state.showCityInput) {
        const wasHidden = $.cityOverlay.classList.contains('hidden');
        $.cityOverlay.classList.remove('hidden');
        if (wasHidden) {
            $.cityInput.value = '';
            $.cityInput.focus();
        }
    } else {
        $.cityOverlay.classList.add('hidden');
    }
}


// ========================================
// TAGES-DETAIL BOTTOM SHEET
// Zeigt st√ºndliche Temperatur- und Regengraphen f√ºr einen ausgew√§hlten Tag.
// ========================================

// ----------------------------------------
// Funktion: buildDayHourlyData
// Verantwortlichkeit: Filtert state.rawHourly auf exakt einen Kalendertag (00:00‚Äì23:00).
// Ver√§ndert: Nichts (pure Funktion)
// Ver√§ndert NICHT: state, DOM
// ----------------------------------------
function buildDayHourlyData(dateString) {
    if (!state.rawHourly || !state.rawHourly.time) return [];
    const result = [];
    for (let i = 0; i < state.rawHourly.time.length; i++) {
        // rawHourly.time enth√§lt ISO-Strings wie "2025-05-10T14:00"
        if (state.rawHourly.time[i].substring(0, 10) === dateString) {
            result.push({
                timeISO: state.rawHourly.time[i],
                temperature: Math.round(state.rawHourly.temperature_2m[i]),
                rainProbability: state.rawHourly.precipitation_probability
                    ? state.rawHourly.precipitation_probability[i]
                    : 0
            });
        }
    }
    return result;
}

// ----------------------------------------
// Funktion: updateDayDetailSheet
// Verantwortlichkeit: Rendert Inhalt des Tages-Detail-Sheets. Steuert Overlay + Body-Lock.
// Ver√§ndert: DOM (day-sheet-overlay, day-sheet-title, SVGs, body classList)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Animation (sheet-open Klasse) wird von open/close-Handlern gesteuert.
// ----------------------------------------
let _currentDayData = [];
let _dayTempLayout = null;
let _dayRainLayout = null;

function updateDayDetailSheet() {
    // Geschlossen und nicht animierend ‚Üí Overlay deaktivieren, Scroll freigeben
    if (state.selectedDayIndex === null) {
        if (!state.isSheetOpen) {
            $.daySheetOverlay.classList.remove('sheet-active');
        }
        return;
    }
    const day = state.forecast[state.selectedDayIndex];
    if (!day) return;

    // Titel setzen: z.B. "Heute, 12. Mai"
    const dayLabel = formatDay(day.date);
    const dateObj = new Date(day.date + 'T00:00:00');
    const months = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
    $.daySheetTitle.textContent = dayLabel + ', ' + dateObj.getDate() + '. ' + months[dateObj.getMonth()];

    // Stundendaten aufbauen und Graphen rendern
    _currentDayData = buildDayHourlyData(day.date);
    updateDayTemperatureGraph(_currentDayData);
    updateDayRainGraph(_currentDayData);

    // Overlay anzeigen + Body sperren (Sheet-Panel startet bei translateY(100%))
    $.daySheetOverlay.classList.add('sheet-active');
    $.app.style.overflowY = 'hidden';
}

// ----------------------------------------
// SVG-Hilfsfunktion: Erstellt ein SVG-Element mit Attributen.
// ----------------------------------------
const _svgNS = 'http://www.w3.org/2000/svg';
function _svgEl(tag, attrs) {
    const node = document.createElementNS(_svgNS, tag);
    for (const k in attrs) {
        if (attrs.hasOwnProperty(k)) node.setAttribute(k, attrs[k]);
    }
    return node;
}

// ----------------------------------------
// Funktion: updateDayTemperatureGraph
// Verantwortlichkeit: Zeichnet den st√ºndlichen Temperatur-Graphen (Linie + Punkte) in das Day-Sheet.
// Ver√§ndert: DOM (day-temp-graph SVG Kindelemente)
// Ver√§ndert NICHT: state
// ----------------------------------------
function updateDayTemperatureGraph(dayData) {
    const svg = $.dayTempGraph;
    if (dayData.length === 0) { svg.replaceChildren(); return; }

    const W = 320, H = 160;
    const padL = 30, padR = 10, padT = 20, padB = 25;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    const n = dayData.length;

    // Dynamische Y-Skalierung
    const temps = dayData.map(function(d) { return d.temperature; });
    const tMin = Math.min.apply(null, temps) - 2;
    const tMax = Math.max.apply(null, temps) + 2;
    const tRange = tMax - tMin || 1;

    function xPos(i) { return padL + (plotW / (n - 1)) * i; }
    function yPos(t) { return padT + plotH - ((t - tMin) / tRange) * plotH; }

    const frag = document.createDocumentFragment();

    // Horizontale Grid-Lines mit Temperaturwerten
    const gridSteps = 4;
    for (let g = 0; g <= gridSteps; g++) {
        const yy = padT + (plotH / gridSteps) * g;
        const tempVal = Math.round(tMax - (g / gridSteps) * (tMax - tMin));
        frag.appendChild(_svgEl('line', {
            x1: padL, y1: yy.toFixed(1), x2: W - padR, y2: yy.toFixed(1),
            stroke: 'rgba(255,255,255,0.08)', 'stroke-width': '0.5'
        }));
        const label = _svgEl('text', {
            x: (padL - 4).toString(), y: (yy + 3).toFixed(1),
            'text-anchor': 'end', fill: 'rgba(255,255,255,0.4)',
            'font-size': '8', 'font-family': 'inherit'
        });
        label.textContent = tempVal + '¬∞';
        frag.appendChild(label);
    }

    // Pfad bauen
    let path = '';
    for (let i = 0; i < n; i++) {
        path += (i === 0 ? 'M' : 'L') + xPos(i).toFixed(1) + ',' + yPos(dayData[i].temperature).toFixed(1);
    }

    // Linie
    frag.appendChild(_svgEl('path', {
        d: path, fill: 'none', stroke: 'rgba(255,255,255,0.9)',
        'stroke-width': '2', 'stroke-linecap': 'round', 'stroke-linejoin': 'round',
        class: 'graph-line'
    }));

    // Punkte
    for (let i = 0; i < n; i++) {
        const delay = (i * 0.03 + 0.3) + 's';
        frag.appendChild(_svgEl('circle', {
            cx: xPos(i).toFixed(1), cy: yPos(dayData[i].temperature).toFixed(1), r: '2.5',
            fill: 'white', class: 'graph-dot', style: 'animation-delay:' + delay
        }));
    }

    // X-Achsen-Labels: 00, 06, 12, 18
    const xLabels = [0, 6, 12, 18];
    for (let li = 0; li < xLabels.length; li++) {
        const h = xLabels[li];
        if (h < n) {
            const lbl = _svgEl('text', {
                x: xPos(h).toFixed(1), y: (H - 6).toString(),
                'text-anchor': 'middle', fill: 'rgba(255,255,255,0.5)',
                'font-size': '9', 'font-family': 'inherit'
            });
            lbl.textContent = (h < 10 ? '0' : '') + h + ':00';
            frag.appendChild(lbl);
        }
    }

    svg.replaceChildren(frag);

    // Layout-Daten f√ºr Graph-Interaktion speichern
    _dayTempLayout = { padL: padL, padR: padR, padT: padT, padB: padB, plotW: plotW, plotH: plotH, n: n, tMin: tMin, tRange: tRange };
}

// ----------------------------------------
// Funktion: updateDayRainGraph
// Verantwortlichkeit: Zeichnet den st√ºndlichen Regenwahrscheinlichkeits-Graphen (Fl√§che) in das Day-Sheet.
// Ver√§ndert: DOM (day-rain-graph SVG Kindelemente)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Fixe Y-Skala 0‚Äì100%. Gradient-Fill. Kein Sonderfall bei 0%.
// ----------------------------------------
function updateDayRainGraph(dayData) {
    const svg = $.dayRainGraph;
    if (dayData.length === 0) { svg.replaceChildren(); return; }

    const W = 320, H = 160;
    const padL = 10, padR = 30, padT = 10, padB = 25;
    const plotW = W - padL - padR;
    const plotH = H - padT - padB;
    const n = dayData.length;

    // Fixe Y-Skala: 0‚Äì100
    function xPos(i) { return padL + (plotW / (n - 1)) * i; }
    function yPos(val) { return padT + plotH - (val / 100) * plotH; }

    const frag = document.createDocumentFragment();

    // Gradient-Definition
    const defs = _svgEl('defs', {});
    const grad = _svgEl('linearGradient', { id: 'rainAreaGrad', x1: '0', y1: '0', x2: '0', y2: '1' });
    grad.appendChild(_svgEl('stop', { offset: '0%', 'stop-color': '#38bdf8', 'stop-opacity': '0.20' }));
    grad.appendChild(_svgEl('stop', { offset: '100%', 'stop-color': '#38bdf8', 'stop-opacity': '0.05' }));
    defs.appendChild(grad);
    frag.appendChild(defs);

    // Horizontale Grid-Lines bei 0%, 20%, 40%, 60%, 80%, 100%
    const gridVals = [0, 20, 40, 60, 80, 100];
    for (let g = 0; g < gridVals.length; g++) {
        const yy = yPos(gridVals[g]);
        frag.appendChild(_svgEl('line', {
            x1: padL, y1: yy.toFixed(1), x2: W - padR, y2: yy.toFixed(1),
            stroke: 'rgba(255,255,255,0.08)', 'stroke-width': '0.5'
        }));
        // Prozentwerte rechts
        const label = _svgEl('text', {
            x: (W - padR + 4).toString(), y: (yy + 3).toFixed(1),
            'text-anchor': 'start', fill: 'rgba(255,255,255,0.4)',
            'font-size': '8', 'font-family': 'inherit'
        });
        label.textContent = gridVals[g] + '%';
        frag.appendChild(label);
    }

    // Fl√§chen-Pfad bauen
    let linePath = '';
    let areaPath = '';
    for (let i = 0; i < n; i++) {
        const px = xPos(i).toFixed(1);
        const py = yPos(dayData[i].rainProbability).toFixed(1);
        linePath += (i === 0 ? 'M' : 'L') + px + ',' + py;
        areaPath += (i === 0 ? 'M' : 'L') + px + ',' + py;
    }
    // Fl√§che schlie√üen: unten entlang zur√ºck
    areaPath += 'L' + xPos(n - 1).toFixed(1) + ',' + yPos(0).toFixed(1);
    areaPath += 'L' + xPos(0).toFixed(1) + ',' + yPos(0).toFixed(1) + 'Z';

    // Gef√ºllte Fl√§che
    frag.appendChild(_svgEl('path', {
        d: areaPath, fill: 'url(#rainAreaGrad)'
    }));

    // Linie
    frag.appendChild(_svgEl('path', {
        d: linePath, fill: 'none', stroke: '#38bdf8',
        'stroke-width': '1.5', 'stroke-linecap': 'round', 'stroke-linejoin': 'round',
        'stroke-opacity': '0.7', class: 'graph-line'
    }));

    // X-Achsen-Labels: 00, 06, 12, 18
    const xLabels = [0, 6, 12, 18];
    for (let li = 0; li < xLabels.length; li++) {
        const h = xLabels[li];
        if (h < n) {
            const lbl = _svgEl('text', {
                x: xPos(h).toFixed(1), y: (H - 6).toString(),
                'text-anchor': 'middle', fill: 'rgba(255,255,255,0.5)',
                'font-size': '9', 'font-family': 'inherit'
            });
            lbl.textContent = (h < 10 ? '0' : '') + h + ':00';
            frag.appendChild(lbl);
        }
    }

    svg.replaceChildren(frag);

    // Layout-Daten f√ºr Graph-Interaktion speichern
    _dayRainLayout = { padL: padL, padR: padR, padT: padT, padB: padB, plotW: plotW, plotH: plotH, n: n };
}


// ========================================
// GRAPH-INTERAKTION (Tages-Detail)
// Pointermove √ºber SVG ‚Üí Highlight-Linie + Tooltip.
// Kein State-Mutation. Kein Reflow-Spam.
// ========================================

// ----------------------------------------
// Funktion: handleDayGraphPointer
// Verantwortlichkeit: Zeigt Highlight-Linie, Punkt und Tooltip bei Pointer-Bewegung √ºber einen Day-Graph.
// Ver√§ndert: DOM (SVG highlight-Gruppe, Tooltip)
// Ver√§ndert NICHT: state
// ----------------------------------------
function handleDayGraphPointer(e, svg, layout, valueFn) {
    if (!_currentDayData.length || !layout) return;
    const rect = svg.getBoundingClientRect();
    const relX = (e.clientX - rect.left) / rect.width;
    const svgX = relX * 320;
    const rawIdx = (svgX - layout.padL) / layout.plotW * (layout.n - 1);
    const idx = Math.max(0, Math.min(layout.n - 1, Math.round(rawIdx)));
    const d = _currentDayData[idx];
    if (!d) return;

    const cx = layout.padL + (layout.plotW / (layout.n - 1)) * idx;
    const cy = valueFn(d, layout);

    // Highlight-Gruppe im SVG erzeugen oder aktualisieren
    let hl = svg.querySelector('[data-hl]');
    if (!hl) {
        hl = document.createElementNS(_svgNS, 'g');
        hl.setAttribute('data-hl', '1');
        svg.appendChild(hl);
    }
    hl.replaceChildren(
        _svgEl('line', {
            x1: cx.toFixed(1), y1: layout.padT.toString(),
            x2: cx.toFixed(1), y2: (layout.padT + layout.plotH).toString(),
            stroke: 'rgba(255,255,255,0.3)', 'stroke-width': '1', 'stroke-dasharray': '3,3'
        }),
        _svgEl('circle', {
            cx: cx.toFixed(1), cy: cy.toFixed(1), r: '5',
            fill: 'white', 'fill-opacity': '0.9'
        })
    );

    // Tooltip positionieren (fixed)
    const hStr = new Date(d.timeISO).getHours().toString().padStart(2, '0') + ':00';
    $.dayGraphTooltip.textContent = hStr + '   ' + d.temperature + '¬∞   ' + d.rainProbability + '%';
    $.dayGraphTooltip.classList.remove('hidden');
    const ttW = $.dayGraphTooltip.offsetWidth;
    let left = e.clientX - ttW / 2;
    if (left < 8) left = 8;
    if (left + ttW > window.innerWidth - 8) left = window.innerWidth - ttW - 8;
    $.dayGraphTooltip.style.left = left + 'px';
    $.dayGraphTooltip.style.top = (rect.top - 36) + 'px';
}

// ----------------------------------------
// Funktion: handleDayGraphLeave
// Verantwortlichkeit: Entfernt Highlight und Tooltip beim Verlassen des Graphen.
// Ver√§ndert: DOM (SVG highlight-Gruppe, Tooltip)
// Ver√§ndert NICHT: state
// ----------------------------------------
function handleDayGraphLeave(svg) {
    const hl = svg.querySelector('[data-hl]');
    if (hl) hl.remove();
    $.dayGraphTooltip.classList.add('hidden');
}


// ========================================
// SHEET DRAG-TO-DISMISS
// Pointer-Events auf dem Drag-Handle steuern das Herunterziehen.
// Nur vertikale Bewegung nach unten. √úber 120px ‚Üí Sheet schlie√üen.
// ========================================

let _isDragging = false;
let _dragStartY = 0;
let _dragCurrentOffset = 0;

// ----------------------------------------
// Funktion: handleSheetPointerDown
// Verantwortlichkeit: Startet den Drag-Vorgang auf dem Sheet-Handle.
// Ver√§ndert: Drag-State (_isDragging, _dragStartY)
// Ver√§ndert NICHT: state
// ----------------------------------------
function handleSheetPointerDown(e) {
    _isDragging = true;
    _dragStartY = e.clientY;
    _dragCurrentOffset = 0;
    $.daySheet.classList.add('sheet-dragging');
    $.daySheetHandle.setPointerCapture(e.pointerId);
    e.preventDefault();
}

// ----------------------------------------
// Funktion: handleSheetPointerMove
// Verantwortlichkeit: Aktualisiert die Sheet-Position w√§hrend des Drags.
// Ver√§ndert: DOM (day-sheet transform, overlay opacity)
// Ver√§ndert NICHT: state
// ----------------------------------------
function handleSheetPointerMove(e) {
    if (!_isDragging) return;
    const dy = e.clientY - _dragStartY;
    _dragCurrentOffset = Math.max(0, dy);
    $.daySheet.style.transform = 'translateY(' + _dragCurrentOffset + 'px)';
    // Overlay abdunkeln proportional zum Drag
    const progress = Math.min(_dragCurrentOffset / 300, 1);
    $.daySheetOverlay.style.opacity = (1 - progress * 0.5).toString();
}

// ----------------------------------------
// Funktion: handleSheetPointerUp
// Verantwortlichkeit: Beendet den Drag. > 120px ‚Üí schlie√üen, sonst snap zur√ºck.
// Ver√§ndert: state (via handleCloseDaySheet), DOM
// Ver√§ndert NICHT: ‚Äî
// ----------------------------------------
function handleSheetPointerUp() {
    if (!_isDragging) return;
    _isDragging = false;
    $.daySheet.classList.remove('sheet-dragging');
    $.daySheet.style.transform = '';
    $.daySheetOverlay.style.opacity = '';

    if (_dragCurrentOffset > 120) {
        // Schwelle √ºberschritten ‚Üí Sheet schlie√üen
        handleCloseDaySheet();
    } else {
        // Snap zur√ºck zur offenen Position
        $.daySheet.classList.add('sheet-open');
    }
    _dragCurrentOffset = 0;
}


// ========================================
// EVENT-HANDLER
// Ver√§ndern ausschlie√ülich state ‚Üí updateUI().
// Kein DOM-Zugriff in Event-Handlern.
// Nur benannte Funktionen. Keine anonymen Handler.
// ========================================

// ----------------------------------------
// Funktion: handleToggleCity
// Verantwortlichkeit: √ñffnet das Stadteingabe-Overlay.
// Ver√§ndert: state.showCityInput, state.cityInputValue
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function handleToggleCity() {
    state.showCityInput = true;
    state.cityInputValue = '';
    updateUI();
}

// ----------------------------------------
// Funktion: handleCancelCity
// Verantwortlichkeit: Schlie√üt das Stadteingabe-Overlay.
// Ver√§ndert: state.showCityInput, state.cityInputValue
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function handleCancelCity() {
    state.showCityInput = false;
    state.cityInputValue = '';
    updateUI();
}

// ----------------------------------------
// Funktion: handleCityInput
// Verantwortlichkeit: Synchronisiert den Eingabewert in den State.
// Ver√§ndert: state.cityInputValue
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Liest den Wert aus dem Event-Objekt (e.target.value).
// ----------------------------------------
function handleCityInput(e) {
    state.cityInputValue = e.target.value;
    updateUI();
}

// ----------------------------------------
// Funktion: handleCitySubmit
// Verantwortlichkeit: L√∂st die Stadtsuche mit dem aktuellen Eingabewert aus.
// Ver√§ndert: state.showCityInput, state.cityInputValue
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function handleCitySubmit() {
    const query = state.cityInputValue.trim();
    if (!query) return;
    state.showCityInput = false;
    state.cityInputValue = '';
    updateUI();
    searchCity(query);
}

// ----------------------------------------
// Funktion: handleCityKeydown
// Verantwortlichkeit: Reagiert auf Enter-Taste im Stadteingabe-Feld.
// Ver√§ndert: state (delegiert an handleCitySubmit)
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function handleCityKeydown(e) {
    if (e.key === 'Enter') {
        handleCitySubmit();
    }
}

// ----------------------------------------
// Funktion: handleRefresh
// Verantwortlichkeit: L√∂st einen erneuten Wetter-Fetch aus.
// Ver√§ndert: Nichts direkt (delegiert an fetchWeather)
// Ver√§ndert NICHT: DOM
// ----------------------------------------
function handleRefresh() {
    if (state.latitude !== null && state.longitude !== null) {
        fetchWeather();
    }
}

// ----------------------------------------
// Funktion: handleForecastDayClick
// Verantwortlichkeit: √ñffnet das Tages-Detail-Sheet mit Slide-Animation.
// Ver√§ndert: state.selectedDayIndex, state.isSheetOpen
// Architektur-Hinweis: Zweistufige rAF f√ºr saubere CSS-Transition.
// ----------------------------------------
function handleForecastDayClick(e) {
    const idx = parseInt(e.currentTarget.getAttribute('data-day-index'));
    state.selectedDayIndex = idx;
    state.isSheetOpen = true;
    updateUI();
    // Zweistufige rAF: Browser rendert Overlay + Sheet bei translateY(100%), dann Animation starten
    requestAnimationFrame(function() {
        requestAnimationFrame(function() {
            $.daySheet.classList.add('sheet-open');
        });
    });
}

// ----------------------------------------
// Funktion: handleCloseDaySheet
// Verantwortlichkeit: Schlie√üt das Tages-Detail-Sheet mit Slide-Out-Animation.
// Ver√§ndert: state.selectedDayIndex, state.isSheetOpen
// Architektur-Hinweis: Sheet f√§hrt nach unten, danach Overlay ausblenden + State zur√ºcksetzen.
// ----------------------------------------
function handleCloseDaySheet() {
    state.isSheetOpen = false;
    $.app.style.overflowY = 'auto';
    $.daySheet.classList.remove('sheet-open');
    // Highlight + Tooltip aufr√§umen
    handleDayGraphLeave($.dayTempGraph);
    handleDayGraphLeave($.dayRainGraph);

    $.daySheet.addEventListener('transitionend', function onSheetClosed() {
        $.daySheet.removeEventListener('transitionend', onSheetClosed);
        state.selectedDayIndex = null;
        $.daySheetOverlay.classList.remove('sheet-active');
        _currentDayData = [];
    }, { once: true });
    // Fallback falls transitionend nicht feuert
    setTimeout(function() {
        if (state.selectedDayIndex !== null && !state.isSheetOpen) {
            state.selectedDayIndex = null;
            $.daySheetOverlay.classList.remove('sheet-active');
            _currentDayData = [];
        }
    }, 400);
}


// ========================================
// ASYNC / SIDE-EFFECTS
// Ver√§ndern ausschlie√ülich state ‚Üí updateUI().
// Kein DOM-Zugriff. Fehler laufen √ºber state.error.
// ========================================

// ----------------------------------------
// Funktion: detectLocation
// Verantwortlichkeit: Ermittelt die GPS-Koordinaten des Nutzers.
// Ver√§ndert: state (via setLocation, setError, setLoading)
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Erster Side-Effect im Lifecycle. L√∂st bei Erfolg fetchWeather() aus.
// ----------------------------------------
function detectLocation() {
    setLoading(true);

    if (!navigator.geolocation) {
        setError('Geolocation wird von diesem Browser nicht unterst√ºtzt.');
        return;
    }

    navigator.geolocation.getCurrentPosition(
        function onGpsSuccess(position) {
            setLocation(position.coords.latitude, position.coords.longitude, 'Mein Standort');
            fetchWeather();
        },
        function onGpsError() {
            setError('Standort konnte nicht ermittelt werden. Bitte Stadt manuell eingeben.');
        },
        { enableHighAccuracy: false, timeout: 10000 }
    );
}

// ----------------------------------------
// Funktion: fetchWeather
// Verantwortlichkeit: Ruft die Open-Meteo Forecast API ab und schreibt die Daten in state.
// Ver√§ndert: state (via setWeatherData, setError, setLoading)
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Kein Caching ‚Äì jeder Aufruf ist ein frischer Fetch.
// ----------------------------------------
async function fetchWeather() {
    setLoading(true);

    const url = 'https://api.open-meteo.com/v1/forecast'
        + '?latitude=' + state.latitude
        + '&longitude=' + state.longitude
        + '&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m'
        + '&daily=weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,precipitation_probability_max,wind_speed_10m_max'
        + '&timezone=auto'
        + '&forecast_days=10'
        + '&hourly=temperature_2m,weather_code,precipitation_probability';

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('HTTP ' + response.status);
        const data = await response.json();
        setWeatherData(data);
    } catch (err) {
        setError('Wetterdaten konnten nicht geladen werden.');
    }
}

// ----------------------------------------
// Funktion: searchCity
// Verantwortlichkeit: Sucht eine Stadt √ºber die Open-Meteo Geocoding API.
// Ver√§ndert: state (via setLocation, setError, setLoading)
// Ver√§ndert NICHT: DOM
// Architektur-Hinweis: Bei Erfolg wird automatisch fetchWeather() ausgel√∂st.
// ----------------------------------------
async function searchCity(query) {
    setLoading(true);

    const url = 'https://geocoding-api.open-meteo.com/v1/search'
        + '?name=' + encodeURIComponent(query)
        + '&count=1'
        + '&language=de'
        + '&format=json';

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('HTTP ' + response.status);
        const data = await response.json();

        if (!data.results || data.results.length === 0) {
            setError('Stadt ‚Äû' + query + '" wurde nicht gefunden.');
            return;
        }

        const result = data.results[0];
        setLocation(result.latitude, result.longitude, result.name);
        fetchWeather();
    } catch (err) {
        setError('Stadtsuche fehlgeschlagen.');
    }
}


// ========================================
// LIFECYCLE
// Zwingende Reihenfolge:
// 1. DOM cachen
// 2. Events binden
// 3. State initialisieren
// 4. UI aktualisieren
// 5. Side-Effects starten (GPS ‚Üí Forecast)
// ========================================

// ----------------------------------------
// Funktion: bindEvents
// Verantwortlichkeit: Bindet alle Event-Handler an die gecachten DOM-Elemente.
// Ver√§ndert: DOM (Event-Listener)
// Ver√§ndert NICHT: state
// Architektur-Hinweis: Ausschlie√ülich benannte Funktionen. Keine anonymen Handler.
// ----------------------------------------
function bindEvents() {
    $.cityToggleBtn.addEventListener('click', handleToggleCity);
    $.cityCancelBtn.addEventListener('click', handleCancelCity);
    $.citySubmitBtn.addEventListener('click', handleCitySubmit);
    $.cityInput.addEventListener('input', handleCityInput);
    $.cityInput.addEventListener('keydown', handleCityKeydown);
    $.refreshBtn.addEventListener('click', handleRefresh);

    // Tages-Detail-Sheet: Klick auf Overlay (nicht auf Sheet selbst) schlie√üt
    $.daySheetOverlay.addEventListener('click', function handleSheetOverlayClick(e) {
        if (e.target === $.daySheetOverlay) handleCloseDaySheet();
    });

    // Sheet Drag-to-Dismiss auf dem Handle
    $.daySheetHandle.addEventListener('pointerdown', handleSheetPointerDown);
    $.daySheetHandle.addEventListener('pointermove', handleSheetPointerMove);
    $.daySheetHandle.addEventListener('pointerup', handleSheetPointerUp);
    $.daySheetHandle.addEventListener('pointercancel', handleSheetPointerUp);

    // Graph-Interaktion: Temperatur-Graph
    $.dayTempGraph.addEventListener('pointermove', function handleTempPointer(e) {
        handleDayGraphPointer(e, $.dayTempGraph, _dayTempLayout, function(d, L) {
            return L.padT + L.plotH - ((d.temperature - L.tMin) / L.tRange) * L.plotH;
        });
    });
    $.dayTempGraph.addEventListener('pointerleave', function handleTempLeave() {
        handleDayGraphLeave($.dayTempGraph);
    });

    // Graph-Interaktion: Regen-Graph
    $.dayRainGraph.addEventListener('pointermove', function handleRainPointer(e) {
        handleDayGraphPointer(e, $.dayRainGraph, _dayRainLayout, function(d, L) {
            return L.padT + L.plotH - (d.rainProbability / 100) * L.plotH;
        });
    });
    $.dayRainGraph.addEventListener('pointerleave', function handleRainLeave() {
        handleDayGraphLeave($.dayRainGraph);
    });
}

// ----------------------------------------
// Funktion: init
// Verantwortlichkeit: Startet die Anwendung in der vorgeschriebenen Lifecycle-Reihenfolge.
// Ver√§ndert: Alles (orchestriert den gesamten App-Start)
// Ver√§ndert NICHT: ‚Äî
// Architektur-Hinweis: Einziger Einstiegspunkt der Anwendung.
// ----------------------------------------
function init() {
    cacheDom();                  // 1. DOM cachen
    bindEvents();                // 2. Events binden
    state.isLoading = true;      // 3. State initialisieren
    updateUI();                  // 4. UI aktualisieren
    detectLocation();            // 5. Side-Effects starten
}

init();

</script>
</body>
</html>

